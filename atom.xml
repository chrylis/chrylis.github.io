<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Hardbits</title>
 <link href="https://blog.chrylis.com/atom.xml" rel="self"/>
 <link href="https://blog.chrylis.com/"/>
 <updated>2015-11-20T20:34:58+00:00</updated>
 <id>https://blog.chrylis.com</id>
 <author>
   <name>Christopher Smith</name>
   <email>chrylis@gmail.com</email>
 </author>

 
 <entry>
   <title>GJT: Annoception</title>
   <link href="https://blog.chrylis.com/2015/11/20/gjt-annoception/"/>
   <updated>2015-11-20T00:00:00+00:00</updated>
   <id>https://blog.chrylis.com/2015/11/20/gjt-annoception</id>
   <content type="html">&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;code-setup-code&quot;&gt;&lt;code&gt;setup()&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;After &lt;a href=&quot;/2015/11/19/gjt-refactoring-transformation/&quot;&gt;refactoring the &lt;code&gt;@GjtVersion&lt;/code&gt;
transformation&lt;/a&gt;, we&amp;#8217;re ready to crank out &lt;code&gt;@GjtId&lt;/code&gt;. The new transformation has a twist,
though&amp;#8212;&amp;#8203;unlike the &lt;code&gt;@Version&lt;/code&gt; property, which is rather plain, JPA &lt;code&gt;@Id&lt;/code&gt; fields usually carry
additional project-specific annotations to specify attributes such as generation strategies.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We&amp;#8217;ll start by adding an &lt;code&gt;@Id&lt;/code&gt; without further annotations, then look into how to supply additional
annotations to &lt;code&gt;@GjtId&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;code-run-code&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;no-frills-code-id-code&quot;&gt;No-frills &lt;code&gt;@Id&lt;/code&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;After the refactor, this is trivially easy:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;GjtId.java&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#007&quot;&gt;@Target&lt;/span&gt;(&lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;ElementType&lt;/span&gt;.TYPE)
&lt;span style=&quot;color:#007&quot;&gt;@Retention&lt;/span&gt;(&lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;RetentionPolicy&lt;/span&gt;.SOURCE)
&lt;span style=&quot;color:#007&quot;&gt;@GroovyASTTransformationClass&lt;/span&gt;(&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;com.chrylis.gjt.transform.GjtIdAstTransformation&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;)
&lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color:#007&quot;&gt;@interface&lt;/span&gt; GjtId {

    &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Class&lt;/span&gt;&amp;lt;?&amp;gt; type() &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;default&lt;/span&gt; &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Long&lt;/span&gt;.class;

    &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;String&lt;/span&gt; name() &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;default&lt;/span&gt; &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;id&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;GjtIdAstTransformation.java&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#007&quot;&gt;@GroovyASTTransformation&lt;/span&gt;(phase = CompilePhase.SEMANTIC_ANALYSIS)
&lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color:#339;font-weight:bold&quot;&gt;class&lt;/span&gt; &lt;span style=&quot;color:#B06;font-weight:bold&quot;&gt;GjtIdAstTransformation&lt;/span&gt; &lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;extends&lt;/span&gt; AbstractGjtPropertyAddingAstTransformation&amp;lt;GjtId&amp;gt; {

    &lt;span style=&quot;color:#007&quot;&gt;@Override&lt;/span&gt;
    &lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Class&lt;/span&gt;&amp;lt;GjtId&amp;gt; annotationClass() {
        &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; GjtId.class;
    }

    &lt;span style=&quot;color:#007&quot;&gt;@Override&lt;/span&gt;
    &lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color:#339;font-weight:bold&quot;&gt;boolean&lt;/span&gt; canApplyToClassOnly() {
        &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color:#069&quot;&gt;true&lt;/span&gt;;
    }

    &lt;span style=&quot;color:#007&quot;&gt;@Override&lt;/span&gt;
    &lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;protected&lt;/span&gt; &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Class&lt;/span&gt;&amp;lt;?&amp;gt; identifyingAnnotation() {
        &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; Id.class;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chrylis/groovy-jpa-toolkit/tree/2015-11-20-gjtid-without-nesting/groovy-jpa-annotations/src/test/java/com/chrylis/gjt/transform/GjtIdAstTransformationTest.groovy&quot;&gt;The
Spock specification&lt;/a&gt; is just a find-and-replace copy of the spec for the version transformation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;adding-annotations-to-the-code-id-code&quot;&gt;Adding annotations to the &lt;code&gt;@Id&lt;/code&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Although it&amp;#8217;s a tad cumbersome, Java supports annotations as parameters on other annotations; for
an example, see &lt;a href=&quot;https://docs.oracle.com/javaee/7/api/javax/persistence/Table.html&quot;&gt;the JPA
&lt;code&gt;Table&lt;/code&gt; class&lt;/a&gt;, which can take various &lt;code&gt;Index&lt;/code&gt;es and &lt;code&gt;UniqueConstraint&lt;/code&gt;s. Unfortunately,
despite the fact that all annotations are internally rewritten to extend &lt;code&gt;Annotation&lt;/code&gt;, the actual
base type &lt;code&gt;Annotation&lt;/code&gt; is not permitted as a parameter; you have to specify the individual
annotation type in question.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This isn&amp;#8217;t going to work for us; we want the end user to be able to add arbitrary annotations to the
ID field. There&amp;#8217;s a workaround, but it&amp;#8217;s a hack and a half. Brace yourself!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;the-groovy-code-annotationcollector-code&quot;&gt;The Groovy &lt;code&gt;@AnnotationCollector&lt;/code&gt;&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Groovy has a nifty feature called
&lt;a href=&quot;http://docs.groovy-lang.org/latest/html/api/groovy/transform/AnnotationCollector.html&quot;&gt;the
annotation collector&lt;/a&gt;, which is (naturally) an AST transformation. Annotating an annotation type
with &lt;code&gt;@AnnotationCollector&lt;/code&gt; causes Groovy to fall through a trap door during compilation. Instead
of generating a class file with an annotation type, Groovy serializes information about all of the
annotations attached to the collector (their types and arguments) and creates a class file with a
&lt;em&gt;class&lt;/em&gt; that has a static method &lt;code&gt;value()&lt;/code&gt; that retrieves the annotations that were originally
applied. It then uses the &lt;code&gt;AnnotationCollectorTransform&lt;/code&gt; to intercept any instances where a
collector annotation is applied, rehydrate those annotations, and apply them in its place.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;slyly-inserting-a-collector-annotation-won-t-work&quot;&gt;Slyly inserting a collector annotation won&amp;#8217;t work&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The clever process that permits Groovy to collect annotations that aren&amp;#8217;t permitted on other
annotations (e.g., all the JPA annotations that can only be placed on fields or getters) means that
as far as the JVM is concerned, the collector isn&amp;#8217;t an annotation type. The Groovy compiler scans
for collectors early in the compilation process and replaces them with their contents. The obvious
step of annotating our ID field with a collector just results in an error saying that the collector
isn&amp;#8217;t an annotation. We&amp;#8217;ll have to dig deeper than that.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;paying-the-field-a-visit&quot;&gt;Paying the field a visit&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;code&gt;AnnotationCollectorTransform#visit&lt;/code&gt; method takes AST information about the use of a collector
and returns a list of &lt;code&gt;AnnotationNode&lt;/code&gt;s representing the original collected annotations.
While this method is intended to be called by the compiler during an early pass, it is public, and
with care we can coopt it for our own nefarious purposes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We start by adding a new member to the &lt;code&gt;@GjtId&lt;/code&gt; annotation. While it would be ideal to enforce
somehow that the provided classes were actually annotation collectors, Java generics don&amp;#8217;t provide
any way to filter type parameters by annotation. The best we can do is to require the classes to
extend &lt;code&gt;GroovyObject&lt;/code&gt;, which the output classes for an &lt;code&gt;@AnnotationCollector&lt;/code&gt; do.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;GjtId.java&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Class&lt;/span&gt;&amp;lt;? &lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;extends&lt;/span&gt; GroovyObject&amp;gt;&lt;span style=&quot;color:#339;font-weight:bold&quot;&gt;[]&lt;/span&gt; annotationCollectors() &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;default&lt;/span&gt; {};&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;when-in-trouble-delegate&quot;&gt;&amp;#8220;When in trouble, delegate.&amp;#8221;&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In our transformation implementation, we&amp;#8217;re now going to check the &lt;code&gt;@GjtId&lt;/code&gt; annotation to see
whether it lists any annotation-collector classes. If it does, we&amp;#8217;ll manually pass them to the
processor, collect the resulting rehydrated annotations, and apply them to the field we created.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Since the processor operates on annotations that it finds in the source, we&amp;#8217;re going to have to
generate synthetic annotations for it. Groovy doesn&amp;#8217;t provide any out-of-the-box support for
unpacking potentially multivalued class parameters off of an annotation, so we&amp;#8217;ll define our own
in &lt;code&gt;GjtUtils&lt;/code&gt;. My initial implementation of this logic normalized the first two cases into
empty and singleton lists, respectively, and then shared the rest of the pipeline, but it was a good
bit more difficult to read than the simple conditional logic.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;GjtUtils.java&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;static&lt;/span&gt; &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;List&lt;/span&gt;&amp;lt;ClassNode&amp;gt; getAnnotationMemberClassesValue(AnnotationNode node, &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;String&lt;/span&gt; name) {
    &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Expression&lt;/span&gt; member = node.getMember(name);
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;if&lt;/span&gt; (member == &lt;span style=&quot;color:#069&quot;&gt;null&lt;/span&gt;) {
        &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Collections&lt;/span&gt;.emptyList();
    }

    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;if&lt;/span&gt; (member &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;instanceof&lt;/span&gt; ClassExpression) {
        &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Collections&lt;/span&gt;.singletonList(member.getType());
    }

    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; ((ListExpression) member).getExpressions().stream()
        .map(ClassExpression.class::cast)
        .map(ClassExpression::getType)
        .collect(Collectors.toList());
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now that we have a list of the collector annotation classes, we wrap them in synthetic
&lt;code&gt;AnnotationNode&lt;/code&gt;s and pass them to the processor, which will return a sequence of lists of
nodes. Finally, we apply each of those annotation collections to the new field:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;GjtIdAstTransformation.java&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#007&quot;&gt;@Override&lt;/span&gt;
&lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;protected&lt;/span&gt; &lt;span style=&quot;color:#339;font-weight:bold&quot;&gt;void&lt;/span&gt; doAddProperty(AnnotationNode annotation, ClassNode target, ClassNode type, &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;String&lt;/span&gt; name) {
    PropertyNode property = addProperty(target, type, name);
    FieldNode field = property.getField();

    &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;List&lt;/span&gt;&amp;lt;ClassNode&amp;gt; annotationCollectors = getAnnotationMemberClassesValue(annotation, &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;annotationCollectors&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);

    annotationCollectors.stream()
        .map(AnnotationNode::&lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;new&lt;/span&gt;)
        .map(collector -&amp;gt; collectorProcessor.visit(collector, collector, field, sourceUnit))
        .forEach(field::addAnnotations);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;code-test-code-and-code-verify-code&quot;&gt;&lt;code&gt;test&lt;/code&gt; and &lt;code&gt;verify&lt;/code&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Testing this functionality will be a tad tricky. Fortunately, our friend the &lt;code&gt;GroovyClassLoader&lt;/code&gt;
will make things a bit easier. We can&amp;#8217;t declare annotations as nested types&amp;#8212;&amp;#8203;even if they eventually
get transformed into classes!&amp;mdash;so we&amp;#8217;ll put them in top-level files. Note that while the
&lt;code&gt;@Column&lt;/code&gt; annotation makes sense on an &lt;code&gt;@Id&lt;/code&gt; field, &lt;code&gt;@OneToOne&lt;/code&gt; doesn&amp;#8217;t. We&amp;#8217;ll just be checking
the correctness of the bytecode here, not semantic validity.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;AddColumnName.groovy&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;groovy&quot;&gt;&lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;package&lt;/span&gt; com.chrylis.gjt.transform.annotationcollectors

&lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;import&lt;/span&gt; &lt;span style=&quot;color:#B44;font-weight:bold&quot;&gt;groovy.transform.AnnotationCollector&lt;/span&gt;

&lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;import&lt;/span&gt; &lt;span style=&quot;color:#B44;font-weight:bold&quot;&gt;javax.persistence.Column&lt;/span&gt;

&lt;span style=&quot;color:#007&quot;&gt;@AnnotationCollector&lt;/span&gt;
&lt;span style=&quot;color:#007&quot;&gt;@Column&lt;/span&gt;(name = &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;foobar&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;)
&lt;span style=&quot;color:#007&quot;&gt;@interface&lt;/span&gt; AddColumnName {
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We&amp;#8217;ll copy our class-creator method and alter it to take a list of classes, dropping the annotation
parameter or wrapping the values in brackets as appropriate. Then an ordinary Spock parameterized
test makes sure that the transformation properly handles, zero, one, or infinity nested collectors.
(As an extra defensive check, on the pass where we&amp;#8217;ve added multiple final annotations, we also
verify that their parameters were copied correctly.)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;GjtIdAstTransformationTest.groovy&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;groovy&quot;&gt;&lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;annotation collector correctly copies annotations&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;/span&gt;(&lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;List&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Class&lt;/span&gt;&amp;gt; parameters, &lt;span style=&quot;color:#339;font-weight:bold&quot;&gt;int&lt;/span&gt; numAnnotations) {
    &lt;span style=&quot;color:#606&quot;&gt;given&lt;/span&gt;:
        &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Field&lt;/span&gt; field = makeClassWithAnnotationCollectors(parameters).getDeclaredField(&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;id&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;/span&gt;)

    &lt;span style=&quot;color:#606&quot;&gt;expect&lt;/span&gt;:
        &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Long&lt;/span&gt; == field.type
        field.getAnnotation(Id)
        numAnnotations == field.annotations.length

    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;if&lt;/span&gt;(field.annotations.length == &lt;span style=&quot;color:#00D&quot;&gt;3&lt;/span&gt;) {
        &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;assert&lt;/span&gt; field.getAnnotation(Column).name() == &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;foobar&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;/span&gt;
        &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;assert&lt;/span&gt; field.getAnnotation(OneToOne).mappedBy() == &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;asdf&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;/span&gt;
    }

    &lt;span style=&quot;color:#606&quot;&gt;where&lt;/span&gt;:
        parameters                   || numAnnotations
        &lt;span style=&quot;color:#339;font-weight:bold&quot;&gt;[]&lt;/span&gt;                           || &lt;span style=&quot;color:#00D&quot;&gt;1&lt;/span&gt;
        [AddOneToOne]                || &lt;span style=&quot;color:#00D&quot;&gt;2&lt;/span&gt;
        [AddOneToOne, AddColumnName] || &lt;span style=&quot;color:#00D&quot;&gt;3&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;code-cleanup-code&quot;&gt;&lt;code&gt;cleanup()&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Supporting adding arbitrary annotations to generated fields required quite a bit of spelunking into
the Groovy transformation system, but by leveraging the existing &lt;code&gt;AnnotationCollectorTransform&lt;/code&gt;, we
can define packages of annotations to be applied to them.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Next up will be utilities to help manage the bidirectional relationships that are the source of a
number of common JPA bugs.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;code-getcontext-code&quot;&gt;&lt;code&gt;getContext()&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Andre Steingress&amp;#8217;s &lt;a href=&quot;http://blog.andresteingress.com/2013/01/25/groovy-2-1-the-annotationcollector-annotation/&quot;&gt;writeup
on &lt;code&gt;@AnnotationCollector&lt;/code&gt;&lt;/a&gt; gives a good overview and links to an example by Guillaume on a more
traditional sort of customization.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Kyle Boon &lt;a href=&quot;http://kyleboon.org/blog/2014/01/22/using-meta-annotations-to-dry-your-groovy/&quot;&gt;has
an example&lt;/a&gt; of the sort of composition we&amp;#8217;re headed for.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;git-tags-for-this-post&quot;&gt;Git tags for this post:&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chrylis/groovy-jpa-toolkit/tree/2015-11-20-gjtid-without-nesting&quot;&gt;2015-11-20-gjtid-without-nesting&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chrylis/groovy-jpa-toolkit/tree/2015-11-20-gjtid-with-nesting&quot;&gt;2015-11-20-gjtid-with-nesting&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content>
 </entry>
 
 <entry>
   <title>GJT: Refactoring the transformation</title>
   <link href="https://blog.chrylis.com/2015/11/19/gjt-refactoring-transformation/"/>
   <updated>2015-11-19T00:00:00+00:00</updated>
   <id>https://blog.chrylis.com/2015/11/19/gjt-refactoring-transformation</id>
   <content type="html">&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;code-setup-code&quot;&gt;&lt;code&gt;setup()&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;a href=&quot;/2015/11/17/gjt-parameterized-properties/&quot;&gt;&lt;code&gt;@GjtVersion&lt;/code&gt; AST transformation
that adds a customizable version property to a class&lt;/a&gt; is ready to go, and we can move on to the next
annotation, &lt;code&gt;@GjtId&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As we start thinking about the semantics of &lt;code&gt;@GjtId&lt;/code&gt;, though, it immediately becomes clear that
adding an &lt;code&gt;@Id&lt;/code&gt; is almost exactly the same as adding an &lt;code&gt;@Version&lt;/code&gt;, with the added wrinkle that
ID fields will usually carry some additional annotations such as &lt;code&gt;@GeneratedValue&lt;/code&gt;. Rather than
repeat the logic, we can pull it up into an intermediate abstract class.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;code-run-code&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;analyzing-the-existing-transformation&quot;&gt;Analyzing the existing transformation&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Looking at &lt;a href=&quot;https://github.com/chrylis/groovy-jpa-toolkit/tree/2015-11-17-version-property-parameterized/groovy-jpa-annotations/src/main/java/com/chrylis/gjt/transform/GjtVersionAstTransformation.java#L43-L78&quot;&gt;the
&lt;code&gt;doVisit&lt;/code&gt; method&lt;/a&gt;, we can see a clear, linear structure:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Determine the target class and the name and type of the property to add.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Check whether there&amp;#8217;s a conflicting field (by name).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Check whether there&amp;#8217;s a conflicting member (by annotation).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Select the initial value for the property.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create the property and apply the annotation.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The first three steps are going to be the same for any property adder. Most of the time, we&amp;#8217;ll use
the default initial value for the property type (&lt;code&gt;null&lt;/code&gt;/zero/false), but that might vary, and
we already know that &lt;code&gt;@GjtId&lt;/code&gt; will need to perform some additional manipulation on the ID field
beyond annotating with &lt;code&gt;@Id&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;pulling-up-the-transformation-logic&quot;&gt;Pulling up the transformation logic&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The new intermediate class is called &lt;code&gt;AbstractGjtPropertyAddingAstTransformation&lt;/code&gt; (yes, it&amp;#8217;s kinda
pushing it, but even subclasses won&amp;#8217;t be used directly in client code, and the name is exactly
descriptive).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Extracting the conflict checks into their own methods means that instead of using the early-exit
return as in the existing monolithic transformation, we&amp;#8217;ll need to return a boolean indicating
whether the field name or the annotation conflicts with an existing member. This has the nice side
effect of reducing nested &lt;code&gt;if&lt;/code&gt;s. We also need to use the lookup method to build any required error
message instead of hard-coding the value.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;AbstractGjtPropertyAddingAstTransformation.java&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;protected&lt;/span&gt; &lt;span style=&quot;color:#339;font-weight:bold&quot;&gt;boolean&lt;/span&gt; fieldNameConflicts(&lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;final&lt;/span&gt; ClassNode target, &lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;final&lt;/span&gt; &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;String&lt;/span&gt; name) {
    &lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;final&lt;/span&gt; FieldNode existingField = target.getField(name);

    &lt;span style=&quot;color:#777&quot;&gt;// no conflict, so we&#39;re fine&lt;/span&gt;
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;if&lt;/span&gt; (existingField == &lt;span style=&quot;color:#069&quot;&gt;null&lt;/span&gt;) {
        &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color:#069&quot;&gt;false&lt;/span&gt;;
    }

    &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;StringBuilder&lt;/span&gt; error = &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;new&lt;/span&gt; &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;StringBuilder&lt;/span&gt;(&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;Can&#39;t add field named &lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;).append(name)
        .append(&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt; for @&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;).append(annotationClass().getSimpleName())
        .append(&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt; because it already exists&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);

    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;if&lt;/span&gt; (!existingField.getOwner().equals(target)) {
        error.append(&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt; on superclass &lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;).append(existingField.getOwner().getName());
    }

    addError(error.toString(), existingField);
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color:#069&quot;&gt;true&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Since the common code needs to be able to check for the identifying annotation
(e.g., &lt;code&gt;@Id&lt;/code&gt;), the class has an abstract method to specify it, which is used by the
&lt;code&gt;annotationConflicts&lt;/code&gt; method.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;AbstractGjtPropertyAddingAstTransformation.java&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;protected&lt;/span&gt; &lt;span style=&quot;color:#339;font-weight:bold&quot;&gt;boolean&lt;/span&gt; annotationConflicts(ClassNode target) {
    &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;List&lt;/span&gt;&amp;lt;AnnotatedNode&amp;gt; conflicts = GjtUtils.findAnnotatedMembers(target, IDENTIFYING_ANNOTATION_CLASS_NODE);

    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;if&lt;/span&gt; (conflicts.isEmpty()) {
        &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color:#069&quot;&gt;false&lt;/span&gt;;
    }

    &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;String&lt;/span&gt; error = &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;Class annotated with @&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; + annotationClass().getSimpleName()
        + &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt; can&#39;t have an existing @&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; + identifyingAnnotation().getSimpleName();

    conflicts.forEach(conflict -&amp;gt; addError(error, conflict));
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color:#069&quot;&gt;true&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A very simple transformation like &lt;code&gt;@GjtVersion&lt;/code&gt; that only needs to add the property and doesn&amp;#8217;t
have any additional work to do can be implemented with just a call to &lt;code&gt;addProperty&lt;/code&gt;, but other
transformations will need to take over at this point. The &lt;code&gt;doAddProperty&lt;/code&gt; method is the override
point for more complicated transformations that need to customize the process. Our generalized
&lt;code&gt;doVisit&lt;/code&gt; method is almost a transcript of the structure described above:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;AbstractGjtPropertyAddingAstTransformation.java&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#007&quot;&gt;@Override&lt;/span&gt;
&lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;protected&lt;/span&gt; &lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;final&lt;/span&gt; &lt;span style=&quot;color:#339;font-weight:bold&quot;&gt;void&lt;/span&gt; doVisit(AnnotationNode annotationNode, AnnotatedNode annotatedNode) {
    ClassNode entity = (ClassNode) annotatedNode;
    &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;String&lt;/span&gt; fieldName = getAnnotationMemberStringValue(annotationNode, ANNOTATION_NAME_PARAMETER_NAME);
    ClassNode fieldType = getMemberClassValue(annotationNode, ANNOTATION_TYPE_PARAMETER_NAME, DEFAULT_TYPE_CLASS_NODE);

    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;if&lt;/span&gt; (fieldNameConflicts(entity, fieldName) || annotationConflicts(entity)) {
        &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt;;
    }

    doAddProperty(annotationNode, entity, fieldType, fieldName);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;converting-code-gjtversionasttransformation-code&quot;&gt;Converting &lt;code&gt;GjtVersionAstTransformation&lt;/code&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As we&amp;#8217;ve moved the transformation logic to the superclass, converting the existing implementation is
delightfully simple: Slash out all the methods that do things, along with the constants, and add
a single method that specifies that the transformation is applying &lt;code&gt;@Version&lt;/code&gt; to the new property.
This is the entire class:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;GjtVersionAstTransformation.java&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#007&quot;&gt;@GroovyASTTransformation&lt;/span&gt;(phase = CompilePhase.SEMANTIC_ANALYSIS)
&lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color:#339;font-weight:bold&quot;&gt;class&lt;/span&gt; &lt;span style=&quot;color:#B06;font-weight:bold&quot;&gt;GjtVersionAstTransformation&lt;/span&gt; &lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;extends&lt;/span&gt; AbstractGjtPropertyAddingAstTransformation&amp;lt;GjtVersion&amp;gt; {

    &lt;span style=&quot;color:#007&quot;&gt;@Override&lt;/span&gt;
    &lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Class&lt;/span&gt;&amp;lt;GjtVersion&amp;gt; annotationClass() {
        &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; GjtVersion.class;
    }

    &lt;span style=&quot;color:#007&quot;&gt;@Override&lt;/span&gt;
    &lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color:#339;font-weight:bold&quot;&gt;boolean&lt;/span&gt; canApplyToClassOnly() {
        &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color:#069&quot;&gt;true&lt;/span&gt;;
    }

    &lt;span style=&quot;color:#007&quot;&gt;@Override&lt;/span&gt;
    &lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;protected&lt;/span&gt; &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Class&lt;/span&gt;&amp;lt;?&amp;gt; identifyingAnnotation() {
        &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; Version.class;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;testing&quot;&gt;Testing&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The Spock tests for the transformation pass as-is. However, these tests only check for
success&amp;#8212;&amp;#8203;they don&amp;#8217;t ensure that we fail when conflicts are present. The inline Groovy compilation
process makes negative testing very simple: just add an optional parameter &lt;code&gt;String body&lt;/code&gt; to
&lt;code&gt;makeVersionedClass&lt;/code&gt;, and we can insert conflicts there if we want.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;GjtVersionAstTransformationTest.groovy&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;groovy&quot;&gt;&lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;conflicting field names produce an error&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;/span&gt;() {
    &lt;span style=&quot;color:#606&quot;&gt;when&lt;/span&gt;:
        makeVersionedClass(&lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Long&lt;/span&gt;, &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;version&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;/span&gt;, &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;Long version&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;/span&gt;)

    &lt;span style=&quot;color:#606&quot;&gt;then&lt;/span&gt;:
        MultipleCompilationErrorsException ex = thrown()
        ex.message.contains(&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;@GjtVersion&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;/span&gt;)
        ex.message.contains(&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;already exists&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;/span&gt;)

        &lt;span style=&quot;color:#00D&quot;&gt;1&lt;/span&gt; == ex.errorCollector.errorCount
}

&lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;conflicting annotation produces an error&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;/span&gt;() {
    &lt;span style=&quot;color:#606&quot;&gt;when&lt;/span&gt;:
        makeVersionedClass(&lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Long&lt;/span&gt;, &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;version&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;/span&gt;, &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;@javax.persistence.Version Integer foo&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;/span&gt;)

    &lt;span style=&quot;color:#606&quot;&gt;then&lt;/span&gt;:
        MultipleCompilationErrorsException ex = thrown()
        ex.message.contains(&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;@GjtVersion&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;/span&gt;)
        ex.message.contains(&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;existing @Version&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;/span&gt;)

        &lt;span style=&quot;color:#00D&quot;&gt;1&lt;/span&gt; == ex.errorCollector.errorCount
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;code-cleanup-code&quot;&gt;&lt;code&gt;cleanup()&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We now have a reusable transformation that can inspect a targeted class, verify that there are no
conflicts in naming or annotations, and add an annotated property. &lt;code&gt;@GjtVersion&lt;/code&gt; has been migrated
to this structure, and we have both positive and negative tests passing. Next up, implementing
&lt;code&gt;@GjtId&lt;/code&gt;!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;code-getcontext-code&quot;&gt;&lt;code&gt;getContext()&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;git-tag-for-this-post&quot;&gt;Git tag for this post:&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chrylis/groovy-jpa-toolkit/tree/2015-11-19-gjtversion-refactoring&quot;&gt;2015-11-19-gjtversion-refactoring&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content>
 </entry>
 
 <entry>
   <title>GJT: Adding parameterized properties</title>
   <link href="https://blog.chrylis.com/2015/11/17/gjt-parameterized-properties/"/>
   <updated>2015-11-17T00:00:00+00:00</updated>
   <id>https://blog.chrylis.com/2015/11/17/gjt-parameterized-properties</id>
   <content type="html">&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;code-setup-code&quot;&gt;&lt;code&gt;setup()&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We have &lt;a href=&quot;/2015/11/16/gjt-simple-properties/&quot;&gt;an AST transformation that can add a
property to an annotated class&lt;/a&gt;, but it&amp;#8217;s of limited use to us right now: It&amp;#8217;s hard-coded to add an
&lt;code&gt;@Version Long version&lt;/code&gt;, and we might need to use both a different type and a different name.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this post, we&amp;#8217;ll take the &lt;code&gt;@GjtVersion&lt;/code&gt; annotation and extend it to support overriding both of
those property properties, while providing sensible defaults.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;code-run-code&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;the-annotation&quot;&gt;The annotation&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We&amp;#8217;ll start with the simple part: the annotation itself. The &lt;code&gt;@GjtVersion&lt;/code&gt; annotation is just an
ordinary Java annotation (it&amp;#8217;s actually written in Java!) that happens to have
&lt;code&gt;@GroovyASTTransformationClass&lt;/code&gt; on it, and it can take parameters normally.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I personally prefer to use &lt;code&gt;Instant&lt;/code&gt; from the new &lt;code&gt;java.time&lt;/code&gt; API, but it&amp;#8217;s not supported by all
persistence providers (Hibernate, for example,
&lt;a href=&quot;https://hibernate.atlassian.net/browse/HHH-8844&quot;&gt;requires version 5 and the &lt;code&gt;hibernate-java8&lt;/code&gt;
extension&lt;/a&gt;), and &lt;code&gt;Long&lt;/code&gt; is a sensible default value. In a later post, we&amp;#8217;ll see how to easily
set a project- or organization-wide parameter.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;GjtVersion.java&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#007&quot;&gt;@Target&lt;/span&gt;(&lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;ElementType&lt;/span&gt;.TYPE)
&lt;span style=&quot;color:#007&quot;&gt;@Retention&lt;/span&gt;(&lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;RetentionPolicy&lt;/span&gt;.SOURCE)
&lt;span style=&quot;color:#007&quot;&gt;@GroovyASTTransformationClass&lt;/span&gt;(&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;com.chrylis.gjt.transform.GjtVersionAstTransformation&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;)
&lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color:#007&quot;&gt;@interface&lt;/span&gt; GjtVersion {

    &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Class&lt;/span&gt;&amp;lt;?&amp;gt; type() &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;default&lt;/span&gt; &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Long&lt;/span&gt;.class;

    &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;String&lt;/span&gt; name() &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;default&lt;/span&gt; &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;version&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;the-transformation&quot;&gt;The transformation&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Conveniently, the implementation of the transformation already uses a constant for the name of the
property to be created! We just need to replace the constant with the parameter taken from the
annotation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://melix.github.io/ast-workshop/exercise4-hints.html&quot;&gt;As C&amp;eacute;dric explains&lt;/a&gt;, there&amp;#8217;s a bit
of a trick in that since we&amp;#8217;re dealing with the AST at this point, the value attached to the
&lt;code&gt;AnnotationNode&lt;/code&gt; isn&amp;#8217;t a &lt;code&gt;String&lt;/code&gt;, but rather some sort of AST expression, such as a
&lt;code&gt;ConstantExpression&lt;/code&gt;--or even &lt;code&gt;null&lt;/code&gt; if the user didn&amp;#8217;t specify the value and left it as the
default! The built-in &lt;code&gt;AbstractASTTransformation&lt;/code&gt; class provides a few methods for working with
annotation members, but they have some shortcomings, and we&amp;#8217;ll need to do some handling of our own.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-note&quot; title=&quot;Note&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
By the &lt;code&gt;SEMANTIC_ANALYSIS&lt;/code&gt; phase, where our property-adding transformations are going to run,
&lt;code&gt;&lt;em&gt;String&lt;/em&gt;&lt;/code&gt; members have been replaced with a &lt;code&gt;ConstantExpression&lt;/code&gt;, and we can just read the value
off of that. &lt;code&gt;&lt;em&gt;Class&lt;/em&gt;&lt;/code&gt; members, however, blow up the compiler internals if they aren&amp;#8217;t an immediate
literal; for example, declaring a &lt;code&gt;Class&lt;/code&gt; constant in a constants class and attempting to use that
in the annotation will blow up the Groovy compiler. Since we&amp;#8217;ll be packaging our annotations into
collections, the amount of repetition required here will be minimal.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;reading-default-annotation-values&quot;&gt;Reading default annotation values&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;There&amp;#8217;s no defensible reason why the Java API doesn&amp;#8217;t provide a simple mechanism for reading the
default values of annotation members, but the best option we have is routing through the
Reflection API. The static method &lt;code&gt;GjtUtils.getAnnotationMemberDefault&lt;/code&gt;
provides a simple, throw-an-exception-in-your-face-on-problem interface for getting the default
value of an annotation member, provided an &lt;code&gt;AnnotationNode&lt;/code&gt; or &lt;code&gt;Class&lt;/code&gt;, the name of the member,
and the expected type of the value. Thanks to Spock, we have a very readable test specification
for this method.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;GjtUtilsTest.groovy&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;groovy&quot;&gt;&lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;can retrieve default value for annotation type member&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;/span&gt;() {
    &lt;span style=&quot;color:#606&quot;&gt;expect&lt;/span&gt;:
        &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;version&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;/span&gt; == GjtUtils.getAnnotationMemberDefault(GjtVersion, &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;name&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;String&lt;/span&gt;)
        &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Long&lt;/span&gt; == GjtUtils.getAnnotationMemberDefault(GjtVersion, &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;type&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Class&lt;/span&gt;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This method is now easily composed with the ready-made expression-value-extraction methods in
&lt;code&gt;AbstractASTTransformation&lt;/code&gt; to produce methods that will return the annotation&amp;#8217;s default value
if the value isn&amp;#8217;t specified. (A null-coalescing operator would be nice here.)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;sanity-checking&quot;&gt;Sanity checking&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The JPA specification only permits certain types (basically, the integral primitives and their
wrappers, plus &lt;code&gt;Timestamp&lt;/code&gt;) as version fields, so to be strict we could ensure that the supplied
&lt;code&gt;Class&lt;/code&gt; parameter was in the list. However, different JPA providers have implementation-specific
support for additional types, such as the Java 8 &lt;code&gt;Instant&lt;/code&gt;, and the cost of not validating the
parameter is an obvious and intelligible failure in starting the persistence context. Therefore,
we&amp;#8217;ll pass through the type as-is.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;However, there is a simple, unambiguous error that we can defensively check and provide a
compile-time error message for: multiple &lt;code&gt;@Version&lt;/code&gt; fields. It&amp;#8217;s easy to see how someone using
a collector annotation to declare an entity class might inadvertently add a duplicate version.
To prevent this, we&amp;#8217;ll create a couple of simple helper methods that look through a
&lt;code&gt;ClassNode&lt;/code&gt;&#39;s members (fields, properties, or methods must be specified) for ones that have
a matching annotation; I&amp;#8217;m not sure why this isn&amp;#8217;t included out of the box.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;GjtUtils.java&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;static&lt;/span&gt; &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;List&lt;/span&gt;&amp;lt;MethodNode&amp;gt; findAnnotatedMethods(ClassNode target, ClassNode annotationClass) {
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; target.getMethods().stream()
        .filter(method -&amp;gt; !method.getAnnotations(annotationClass).isEmpty())
        .collect(Collectors.toList());
}

&lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;static&lt;/span&gt; &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;List&lt;/span&gt;&amp;lt;AnnotatedNode&amp;gt; findAnnotatedMembers(ClassNode target, ClassNode annotationClass) {
    &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;List&lt;/span&gt;&amp;lt;AnnotatedNode&amp;gt; result = &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;new&lt;/span&gt; &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;();
    result.addAll(findAnnotatedFields(target, annotationClass));
    result.addAll(findAnnotatedProperties(target, annotationClass));
    result.addAll(findAnnotatedMethods(target, annotationClass));
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; result;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now, in the transformation, we&amp;#8217;ll check to see whether there&amp;#8217;s any existing conflicting member. If
so, we&amp;#8217;ll mark a compile-time error for it:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;GjtVersionAstTransformation.java&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#777&quot;&gt;// error if there&#39;s already an @Version on the class&lt;/span&gt;
&lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;List&lt;/span&gt;&amp;lt;AnnotatedNode&amp;gt; conflicts = GjtUtils.findAnnotatedMembers(entityClass, APPLIED_ANNOTATION_CLASS_NODE);
&lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;if&lt;/span&gt;(!conflicts.isEmpty()) {
    conflicts.forEach(conflict -&amp;gt; addError(&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;Class annotated with GjtVersion cannot have an existing @Version&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, conflict));
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In Eclipse, here&amp;#8217;s what we get when there&amp;#8217;s a conflict:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/public/images/2015/11/17/GjtVersion-existing-version-in-Eclipse.png&quot; alt=&quot;Eclipse error message&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;adding-the-property&quot;&gt;Adding the property&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If there&amp;#8217;s no conflict, we can go ahead and add the field.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For the sake of completeness, GJT supports using the primitive types &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, and &lt;code&gt;long&lt;/code&gt;
for the version field, even though I recommend using a wrapper to avoid any possible ambiguity about
&quot;revision zero&quot;. Since the default value of a primitive is zero, not &lt;code&gt;null&lt;/code&gt;, we need to check
whether the requested type is a primitive and set the appropriate expression for the default:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;GjtVersionAstTransformation.java&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;ConstantExpression fieldDefaultValue = isPrimitiveType(fieldType) ?
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;new&lt;/span&gt; ConstantExpression(&lt;span style=&quot;color:#00D&quot;&gt;0&lt;/span&gt;, &lt;span style=&quot;color:#069&quot;&gt;true&lt;/span&gt;) :
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;new&lt;/span&gt; ConstantExpression(&lt;span style=&quot;color:#069&quot;&gt;null&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;There&amp;#8217;s one more detail that I&amp;#8217;ll mention at this point: According to
&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.1&quot;&gt;the JLS at &amp;sect;13.1&lt;/a&gt;,&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A construct emitted by a Java compiler must be marked as &lt;em&gt;synthetic&lt;/em&gt; if it does not correspond to
a construct declared explicitly or implicitly in source code, unless the emitted construct is a
class initialization method (JVMS §2.9).&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The JLS provides guidance on what constitutes implicit declaration for Java code, but Groovy AST
transformations are a new metaprogramming approach unavailable in Java. The standard practice for
existing AST transformations that add new class members, such as &lt;code&gt;@Slf4j&lt;/code&gt; or &lt;code&gt;@ToString&lt;/code&gt;, is to
consider the members that are the point of the transformation (such as the logger or &lt;code&gt;toString()&lt;/code&gt;
method) to be implicitly declared&amp;#8212;&amp;#8203;the programmer is asking for them by annotating the class&amp;#8212;&amp;#8203;but
internal members that may be added to facilitate the expected additions are synthetic. We&amp;#8217;ll need
to include some of these &quot;implementation detail&quot; members when we start working with bidirectional
relationships.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;testing&quot;&gt;Testing&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In order to ensure that the parameters are working properly, it would be best to have a
comprehensive combinatorial test. However, the transformation is applied only at compile time, and
we don&amp;#8217;t want to manage a herd of test entities just to check combinations.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This is where Groovy&amp;#8217;s roots as a scripting language shine: Groovy has easy support for compiling
classes at runtime from text, and we can just use a multiline GString to define a throwaway class
with string substitutions for the annotation parameters!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;GjtVersionAstTransformationTest.groovy&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;groovy&quot;&gt;&lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Class&lt;/span&gt; makeVersionedClass(&lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Class&lt;/span&gt; type, &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;String&lt;/span&gt; name) {
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;new&lt;/span&gt; GroovyClassLoader().parseClass(&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;
        @groovy.transform.CompileStatic
        @com.chrylis.gjt.annotation.GjtVersion(type=&lt;/span&gt;&lt;span style=&quot;background-color:hsla(0,0%,0%,0.07);color:black&quot;&gt;&lt;span style=&quot;font-weight:bold;color:#666&quot;&gt;$&lt;/span&gt;type&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;.name, name=&amp;quot;&lt;/span&gt;&lt;span style=&quot;background-color:hsla(0,0%,0%,0.07);color:black&quot;&gt;&lt;span style=&quot;font-weight:bold;color:#666&quot;&gt;$&lt;/span&gt;name&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;&amp;quot;)
        class Temp {}&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/span&gt;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now it&amp;#8217;s simple to
&lt;a href=&quot;https://github.com/chrylis/groovy-jpa-toolkit/tree/2015-11-17-version-property-parameterized/groovy-jpa-annotations/src/test/java/com/chrylis/gjt/transform/GjtVersionAstTransformationTest.groovy#L50-L63&quot;&gt;repeat
the basic reflection checks&lt;/a&gt; to verify the presence of the field by name, its type, and that it has
the &lt;code&gt;@Version&lt;/code&gt; annotation applied.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;code-cleanup-code&quot;&gt;&lt;code&gt;cleanup()&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You probably noticed that several aspects of this process, such as checking for collisions and then
adding the property, are pretty much the same regardless of whether we&amp;#8217;re adding an &lt;code&gt;@Version&lt;/code&gt;
or an &lt;code&gt;@Id&lt;/code&gt;, although IDs will usually carry additional parameterized annotations such as
&lt;code&gt;@GeneratedValue&lt;/code&gt;. Next time, when we implement the &lt;code&gt;@GjtId&lt;/code&gt; transformation,
&lt;a href=&quot;/2015/11/19/gjt-refactoring-transformation/&quot;&gt;we&amp;#8217;ll refactor the
&lt;code&gt;doVisit&lt;/code&gt; method and pull all this common functionality out into reusable methods&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;code-getcontext-code&quot;&gt;&lt;code&gt;getContext()&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;git-tag-for-this-post&quot;&gt;Git tag for this post:&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chrylis/groovy-jpa-toolkit/tree/2015-11-17-version-property-parameterized&quot;&gt;2015-11-17-version-property-parameterized&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content>
 </entry>
 
 <entry>
   <title>GJT: Adding simple properties</title>
   <link href="https://blog.chrylis.com/2015/11/16/gjt-simple-properties/"/>
   <updated>2015-11-16T00:00:00+00:00</updated>
   <id>https://blog.chrylis.com/2015/11/16/gjt-simple-properties</id>
   <content type="html">&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;code-setup-code&quot;&gt;&lt;code&gt;setup()&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this post, we&amp;#8217;ll start off by examining the simplest components of
&lt;a href=&quot;/2015/11/13/introducing-gjt/&quot;&gt;the Groovy JPA Toolkit&lt;/a&gt;: transformations that add
a single property to the annotated class, such as ID and version properties. We&amp;#8217;ll also see how to
combine these transformations with information specific to a particular domain configuration, such
as ID generation strategies, in a reusable package with Groovy&amp;#8217;s &lt;code&gt;@AnnotationCollector&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This series assumes some familiarity with the concepts of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;abstract syntax trees&lt;/a&gt; and the Groovy
compilation process. For those wanting additional grounding in the AST transformation process
generally, I recommend &lt;a href=&quot;https://melix.github.io/ast-workshop/&quot;&gt;C&amp;eacute;dric&amp;#8217;s online AST Workshop&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-note&quot; title=&quot;Note&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
I originally considered attempting to target Java 7 for this toolkit. However, the only
major reason for not using Java 8 in modern code is Android compatibility, and these transformations
are exclusively a compile-time operation. In the case of JPA on Android, which is uncommon but not
unheard of, this toolkit should be usable as long as the &lt;em&gt;compiler&lt;/em&gt; used is Java 8 or higher.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;code-run-code&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The simplest transformation we might want is to add a new property to a class where all the
information about the property (such as visibility, type, and annotations) is hard-coded. Possibly
the simplest interesting JPA property is a version field, which allows the JPA provider to perform
&lt;a href=&quot;https://blogs.oracle.com/carolmcdonald/entry/jpa_2_0_concurrency_and&quot;&gt;optimistic locking&lt;/a&gt; on
versioned records. &lt;a href=&quot;https://docs.oracle.com/javaee/7/api/javax/persistence/Version.html&quot;&gt;The Javadoc
for &lt;code&gt;@Version&lt;/code&gt;&lt;/a&gt; specifies that the allowable types for a version field are &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;Integer&lt;/code&gt;,
&lt;code&gt;short&lt;/code&gt;, &lt;code&gt;Short&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;Long&lt;/code&gt;, and &lt;code&gt;java.sql.Timestamp&lt;/code&gt;. Let&amp;#8217;s pick &lt;code&gt;Long&lt;/code&gt; as our version type.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;the-annotation&quot;&gt;The annotation&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The annotation for adding a version property is &lt;code&gt;@GjtVersion&lt;/code&gt;. Most of the out-of-the-box Groovy
transformations, such as &lt;code&gt;@ToString&lt;/code&gt;, use plain names, but using the name &lt;code&gt;@Version&lt;/code&gt; would produce
a conflict with the actual JPA annotation, which we&amp;#8217;re attaching to the property we add. Since
the GJT annotations will usually be composed into an organization-specific annotation collection
and not used directly on the entity classes, I&amp;#8217;m using the &lt;code&gt;Gjt&lt;/code&gt; prefix.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;GjtVersion.java&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#007&quot;&gt;@Target&lt;/span&gt;(&lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;ElementType&lt;/span&gt;.TYPE)
&lt;span style=&quot;color:#007&quot;&gt;@Retention&lt;/span&gt;(&lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;RetentionPolicy&lt;/span&gt;.SOURCE)
&lt;span style=&quot;color:#007&quot;&gt;@GroovyASTTransformationClass&lt;/span&gt;(&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;com.chrylis.gjt.transform.GjtVersionAstTransformation&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;)
&lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color:#007&quot;&gt;@interface&lt;/span&gt; GjtVersion {
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This annotation is about as basic as you can get; we&amp;#8217;re specifying that it&amp;#8217;s only applicable to
&lt;code&gt;TYPE&lt;/code&gt;&amp;#160;s (we&amp;#8217;d use &quot;class&quot;, but there&amp;#8217;s no target available for that), that it doesn&amp;#8217;t need to be
saved in the class file (since it&amp;#8217;s applied at compile time), and the class that implements the
actual transformation. Note that the transformation is applied to the AST node where the annotation
lives, so in this case, it&amp;#8217;ll be called for each annotated class. Some later transformations will
be applied to fields instead.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;the-transformation&quot;&gt;The transformation&lt;/h3&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-note&quot; title=&quot;Note&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
Unfortunately, AST transformations themselves can involve significant amounts of
boilerplate. I&amp;#8217;ve condensed several useful chunks of code out of some of the official Groovy
transformations into the &lt;code&gt;AbstractGjtAstTransformation&lt;/code&gt; class. Additionally, the usual entry point
into a transformation is the &lt;code&gt;visit&lt;/code&gt; method; I&amp;#8217;ve applied the usual Java pattern of implementing
common operations in the abstract base class and then delegating the interesting but more clearly
defined behavior to &lt;code&gt;doVisit&lt;/code&gt;.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I&amp;#8217;ll be including relevant lines from &lt;a href=&quot;https://github.com/chrylis/groovy-jpa-toolkit/tree/2015-11-16-version-field-only/groovy-jpa-annotations/src/main/java/com/chrylis/gjt/transform/GjtVersionAstTransformation.java&quot;&gt;the source
file &lt;code&gt;GjtVersionAstTransformation.java&lt;/code&gt;&lt;/a&gt;
inline in the discussion.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;about-the-transformation&quot;&gt;About the transformation&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;First, let&amp;#8217;s take a look at the &quot;specification&quot; methods, which tell the intermediate abstract class
what annotation this transform is triggered by and that it can only be applied to a class, not an
interface (since the most specific the JDK supports is &lt;code&gt;ElementType.TYPE&lt;/code&gt;, which doesn&amp;#8217;t distinguish
between classes and interfaces):&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;GjtVersionAstTransformation.java&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#007&quot;&gt;@Override&lt;/span&gt;
&lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Class&lt;/span&gt;&amp;lt;GjtVersion&amp;gt; annotationClass() {
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; GjtVersion.class;
}

&lt;span style=&quot;color:#007&quot;&gt;@Override&lt;/span&gt;
&lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color:#339;font-weight:bold&quot;&gt;boolean&lt;/span&gt; canApplyToClassOnly() {
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color:#069&quot;&gt;true&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;These are simple and likely familiar to anyone who&amp;#8217;s worked with this inheritance pattern before.
A bit more interesting is the &lt;code&gt;doVisit&lt;/code&gt; method, which handles actually adding the field. Note that
the signature on the method passes in a node representing the annotation (&lt;code&gt;@GjtVersion&lt;/code&gt;) and one
representing the node that was annotated (in this case, the class), but since many different
elements can be annotated, and we don&amp;#8217;t want just yet to restrict this method to a particular
kind of target, we need to cast the second argument to a &lt;code&gt;ClassNode&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;protected&lt;/span&gt; &lt;span style=&quot;color:#339;font-weight:bold&quot;&gt;void&lt;/span&gt; doVisit(AnnotationNode annotationNode, AnnotatedNode annotatedNode) {
    ClassNode entityClass = (ClassNode) annotatedNode;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;checking-preconditions&quot;&gt;Checking preconditions&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Next, we need to check whether a field named &lt;code&gt;version&lt;/code&gt; already exists on the class&amp;#8212;&amp;#8203;if so, this
is a problem, and we&amp;#8217;ll want to raise an appropriate compile-time error. This can happen either
because the class specifies the field directly or because a superclass specifies the field with a
visibility that allows the subclass to see it. The method &lt;code&gt;addError&lt;/code&gt; is defined on
&lt;code&gt;AbstractASTTransformation&lt;/code&gt; and takes care of attaching information about the source code that
caused the problem.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;FieldNode versionField = entityClass.getField(VERSION_FIELD_NAME);

&lt;span style=&quot;color:#777&quot;&gt;// don&#39;t add the version field if it already exists on this class or is visible from a superclass&lt;/span&gt;
&lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;if&lt;/span&gt; (versionField != &lt;span style=&quot;color:#069&quot;&gt;null&lt;/span&gt;) {
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;if&lt;/span&gt;(versionField.getOwner().equals(entityClass)) {
        addError(&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;Class annotated with GjtVersion cannot have a version field declared&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, versionField);
    } &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;else&lt;/span&gt; &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;if&lt;/span&gt; (!&lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Modifier&lt;/span&gt;.isPrivate(versionField.getModifiers())) {
        addError(&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;Class annotated with GjtVersion cannot have a version field declared because the field exists in the parent class: &lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; + versionField.getOwner().getName(), versionField);
    }

    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For example, in Eclipse, it produces this error output:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/public/images/2015/11/16/GjtVersion-error-in-eclipse.png&quot; alt=&quot;Eclipse error message&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;adding-the-field&quot;&gt;Adding the field!&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Next, we actually attach a new node representing a field to the class, and then add an annotation
node (just like the one that originally triggered this transformation) to it. Note that even though
the Java and Groovy languages will automatically initialize a reference field to &lt;code&gt;null&lt;/code&gt; if no
initializer is provided, since we&amp;#8217;re past the parsing stage and into the AST, we have to specify
that default &lt;code&gt;null&lt;/code&gt; value ourselves.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;versionField = entityClass.addField(VERSION_FIELD_NAME, ACC_PRIVATE, make(&lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Long&lt;/span&gt;.class), &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;new&lt;/span&gt; ConstantExpression(&lt;span style=&quot;color:#069&quot;&gt;null&lt;/span&gt;));
versionField.addAnnotation(&lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;new&lt;/span&gt; AnnotationNode(make(Version.class)));&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;checking-our-work&quot;&gt;Checking our work&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In the &lt;code&gt;groovy-jpa-examples&lt;/code&gt; module, I will be accumulating a number of simple examples for each
of the GJT features. Let&amp;#8217;s start with &lt;code&gt;SimpleEntity&lt;/code&gt;, which just has a single &lt;code&gt;String&lt;/code&gt; value, and
annotate it with &lt;code&gt;@GjtVersion&lt;/code&gt;. I decompiled &lt;code&gt;SimpleEntity.class&lt;/code&gt; with &lt;a href=&quot;http://jd.benow.ca/&quot;&gt;JD-GUI&lt;/a&gt;,
and I got this code:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#007&quot;&gt;@Entity&lt;/span&gt;
&lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color:#339;font-weight:bold&quot;&gt;class&lt;/span&gt; &lt;span style=&quot;color:#B06;font-weight:bold&quot;&gt;SimpleEntity&lt;/span&gt; &lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;implements&lt;/span&gt; GroovyObject {

    &lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;String&lt;/span&gt; contents;

    &lt;span style=&quot;color:#007&quot;&gt;@Version&lt;/span&gt;
    &lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Long&lt;/span&gt; version;

    &lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;public&lt;/span&gt; SimpleEntity() {
      &lt;span style=&quot;color:#777&quot;&gt;// standard Groovy initialization&lt;/span&gt;
    }

    &lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;String&lt;/span&gt; getContents() {
        &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color:#950&quot;&gt;this&lt;/span&gt;.contents;
    }

    &lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color:#339;font-weight:bold&quot;&gt;void&lt;/span&gt; setContents(&lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;String&lt;/span&gt; paramString) {
      &lt;span style=&quot;color:#950&quot;&gt;this&lt;/span&gt;.contents = paramString;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Hmm. The &lt;code&gt;version&lt;/code&gt; field is definitely there, and it has the annotation we expect, but we don&amp;#8217;t have
a getter or setter. This is because we added a just a &lt;em&gt;field&lt;/em&gt; to the class, and not a property.
Adding the property is simple, though unfortunately in Groovy there&amp;#8217;s no easy way to create a
read-only property, which managed properties like this &lt;code&gt;version&lt;/code&gt; really ought to be.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;All we need to do to have Groovy generate our getter and setter is to change our code to add a
&lt;code&gt;PropertyNode&lt;/code&gt; to the class as well. There are a few different ways to do this, designed to make it
easy to perform certain kinds of operations regardless of whether you start with the node for the
target class, the existing field, or so on. Since we&amp;#8217;re going to just let Groovy generate its usual
property code, we&amp;#8217;ll use this approach:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;PropertyNode versionProperty = entityClass.addProperty(VERSION_FIELD_NAME, ACC_PUBLIC, make(&lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Long&lt;/span&gt;.class), &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;new&lt;/span&gt; ConstantExpression(&lt;span style=&quot;color:#069&quot;&gt;null&lt;/span&gt;), &lt;span style=&quot;color:#069&quot;&gt;null&lt;/span&gt;, &lt;span style=&quot;color:#069&quot;&gt;null&lt;/span&gt;);
versionField = versionProperty.getField();
versionField.setModifiers(ACC_PRIVATE);
versionField.addAnnotation(&lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;new&lt;/span&gt; AnnotationNode(make(Version.class)));&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now, sure enough, opening up the class in JD-GUI shows the getter and setter!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Long&lt;/span&gt; getVersion() {
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color:#950&quot;&gt;this&lt;/span&gt;.version;
}

&lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color:#339;font-weight:bold&quot;&gt;void&lt;/span&gt; setVersion(&lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Long&lt;/span&gt; paramLong) {
    &lt;span style=&quot;color:#950&quot;&gt;this&lt;/span&gt;.version = paramLong;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;writing-a-unit-test&quot;&gt;Writing a unit test&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It&amp;#8217;s always comforting to directly see correct results, but down the path of manual testing lies
madness. Groovy provides some assistance in writing test for AST transforms through the &lt;code&gt;@ASTTest&lt;/code&gt;
annotation. This annotation allows us to provide a closure to be evaluated at compile time, against
the in-progress AST. If assertions in the closure fail, the compilation will fail, so we don&amp;#8217;t even
have to have a test runner in place for this test.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock warning&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-warning&quot; title=&quot;Warning&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
However, there&amp;#8217;s one nasty gotcha with AST tests: The AST transformation must be completely compiled
and available on the classpath before the test using the transformation is compiled, since
transformations are actually used by the compiler, not the runtime. The Groovy-Eclipse Compiler, in
particular, has some bugs relating to the handling and ordering of test classpaths, and it&amp;#8217;s not
possible to reliably put tests in the same Maven module as the transformations they&amp;#8217;re testing.
Gradle is a bit saner on this particular point, but Eclipse still won&amp;#8217;t handle the tests correctly,
and I&amp;#8217;ve been unable to find a workaround that works reliably. (Solutions are welcome!)
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As a partial solution, we can use Java reflection to inspect a class that we compile with
&lt;code&gt;@GjtVersion&lt;/code&gt;. I&amp;#8217;m a big fan of &lt;a href=&quot;https://spockframework.github.io/spock/docs/1.0/index.html&quot;&gt;the
Spock Framework&lt;/a&gt;, a test tool written in Groovy that makes tests clear and expressive. Here&amp;#8217;s how
we can test that the field is added, that it has the proper annotation, and that the accessors
were set up correctly:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;CodeRay highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#339;font-weight:bold&quot;&gt;class&lt;/span&gt; &lt;span style=&quot;color:#B06;font-weight:bold&quot;&gt;GjtVersionAstTransformationTest&lt;/span&gt; &lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;extends&lt;/span&gt; Specification {

    &lt;span style=&quot;color:#007&quot;&gt;@GjtVersion&lt;/span&gt;
    &lt;span style=&quot;color:#007&quot;&gt;@CompileStatic&lt;/span&gt;
    &lt;span style=&quot;color:#339;font-weight:bold&quot;&gt;class&lt;/span&gt; &lt;span style=&quot;color:#B06;font-weight:bold&quot;&gt;Versioned&lt;/span&gt; {
    }

    def &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;annotated class has version field&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;/span&gt;() {
        given:
            &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Field&lt;/span&gt; field = Versioned.getDeclaredField(&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;version&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;/span&gt;)

        expect:
            &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Long&lt;/span&gt; == field.type
            field.getAnnotation(Version)
    }

    def &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;getters and setters for version field work&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;/span&gt;() {
        given:
            &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Long&lt;/span&gt; randomNumber = &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;new&lt;/span&gt; &lt;span style=&quot;color:#0a8;font-weight:bold&quot;&gt;Random&lt;/span&gt;().nextLong()

            def v = &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;new&lt;/span&gt; Versioned()
            v.setVersion(randomNumber)

        expect:
            randomNumber == v.getVersion()
            randomNumber == v.&lt;span style=&quot;color:#007&quot;&gt;@version&lt;/span&gt;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;code-cleanup-code&quot;&gt;&lt;code&gt;cleanup()&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We have a working and tested AST transformation that adds an &lt;code&gt;@Version Long version&lt;/code&gt; property to
any class we annotate. That&amp;#8217;s a starting point, but even for a simple operation like adding a field,
we&amp;#8217;re going to need a bit more flexibility, such as an option to name the property and specify the
type. Next time, we&amp;#8217;ll parameterize that &lt;code&gt;@GjtVersion&lt;/code&gt; annotation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;code-getcontext-code&quot;&gt;&lt;code&gt;getContext()&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;git-tags-for-this-post&quot;&gt;Git tags for this post:&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chrylis/groovy-jpa-toolkit/tree/2015-11-16-version-field-only&quot;&gt;2015-11-16-version-field-only&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chrylis/groovy-jpa-toolkit/tree/2015-11-16-version-field-with-property&quot;&gt;2015-11-16-version-field-with-property&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chrylis/groovy-jpa-toolkit/tree/2015-11-16-version-property-test&quot;&gt;2015-11-16-version-property-test&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content>
 </entry>
 
 <entry>
   <title>Introducing the Groovy JPA Toolkit</title>
   <link href="https://blog.chrylis.com/2015/11/13/introducing-gjt/"/>
   <updated>2015-11-13T00:00:00+00:00</updated>
   <id>https://blog.chrylis.com/2015/11/13/introducing-gjt</id>
   <content type="html">&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;code-setup-code&quot;&gt;&lt;code&gt;setup()&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;a href=&quot;https://en.wikibooks.org/wiki/Java_Persistence/What_is_JPA%3F&quot;&gt;Java Persistence API&lt;/a&gt; is a
wonderful tool for mapping Java persistent domain classes onto a data store (usually, but not
always, a SQL database). JPA providers such as &lt;a href=&quot;http://hibernate.org/orm&quot;&gt;Hibernate ORM&lt;/a&gt; manage
mappings, conversions, lazy joins, transactions, and more with minimal effort on our part.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;However, even though JPA is comparatively lightweight (anyone remember
&lt;a href=&quot;https://docs.oracle.com/cd/E16439_01/doc.1013/e13981/ent21imp001.htm&quot;&gt;EJB CMP&lt;/a&gt;?), there are a few
common bits of boilerplate that get repeated ad nauseam, such as specifying &lt;code&gt;@Id&lt;/code&gt; and &lt;code&gt;@Version&lt;/code&gt;
fields, and
&lt;a href=&quot;https://schuchert.wikispaces.com/JPA+Tutorial+1+-+Make+Relationship+Bi-directional&quot;&gt;managing&lt;/a&gt;
&lt;a href=&quot;https://dzone.com/articles/jpa-implementation-patterns-4&quot;&gt;bidirectional&lt;/a&gt;
&lt;a href=&quot;http://blog.jbaysolutions.com/2011/09/19/jpa-2-relationships-onetomany/&quot;&gt;relationships&lt;/a&gt;
is a tedious chore that is prone to subtle heisenbugs. Repetitive code ought to be replaced with
intelligent tooling.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Some of these issues have been addressed to varying degrees:
&lt;a href=&quot;https://projects.spring.io/spring-roo/&quot;&gt;Spring Roo&lt;/a&gt;, for example, uses AspectJ to insert bookkeeping
fields and property accessors into POJOs using inter-type declarations. It is, however, limited in
its capabilities for managing relationships, and it requires Maven as a build system.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;code-run-code&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The Groovy JPA Toolkit is a uniquely Groovy attempt at streamlining the task of writing JPA domain
classes, using the power of Groovy&amp;#8217;s
&lt;a href=&quot;http://www.groovy-lang.org/metaprogramming.html#_compile_time_metaprogramming&quot;&gt;compile-time
AST transformations&lt;/a&gt;, which allow for comprehensive control over classes as they&amp;#8217;re being compiled.
We can insert properties, add annotations to class members, and even &lt;em&gt;modify other classes&lt;/em&gt;, which
permits managing those pesky relationships and even packaging up some common design patterns
into a single annotation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This series will walk through the development of the GJT, which is a refinement of some ad-hoc
tooling I put together while working on a specific domain implementation and learning the
Groovy AST. I&amp;#8217;ll start with the simple transformations of adding properties, and as we pick up steam
we&amp;#8217;ll tackle some of the more complicated longstanding issues with managing object relationships.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;code-getcontext-code&quot;&gt;&lt;code&gt;getContext()&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Most of my own understanding of Groovy&amp;#8217;s compile-time metaprogramming comes from
&lt;a href=&quot;http://www.infoq.com/presentations/groovy-compiler&quot;&gt;C&amp;eacute;dric Champeau&amp;#8217;s presentation on the
Groovy compiler&lt;/a&gt; and &lt;a href=&quot;http://www.infoq.com/presentations/groovy-ast-transformations&quot;&gt;Paul King&amp;#8217;s on
AST transformations&lt;/a&gt;, both at SpringOne2GX 2015, as well as jumping into the source for the &lt;code&gt;@Slf4j&lt;/code&gt;
and &lt;code&gt;@ToString&lt;/code&gt; transformations.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The code is &lt;a href=&quot;https://github.com/chrylis/groovy-jpa-toolkit&quot;&gt;hosted on GitHub&lt;/a&gt; and will be pushed
to &lt;a href=&quot;https://search.maven.org/&quot;&gt;the Central Repository&lt;/a&gt;. Comments on both design and implementation are
welcome. If there&amp;#8217;s a use case that the Toolkit doesn&amp;#8217;t cover that you think can be automated, open
an issue and tell me about it.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content>
 </entry>
 

</feed>
